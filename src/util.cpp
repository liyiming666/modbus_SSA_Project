/*
 * util.cc
 *
 *  Created on: Sep 7, 2018
 *      Author: wenhan
 */

#include <iostream>
#include <fstream>
#include <string.h>
#include <srlogger.h>
#include <srutils.h>
#include "util.h"
#include <boost/thread/mutex.hpp>
#include <iomanip>

const unsigned char G_auchCRCHi[] = {0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,
        0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
        0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80,
        0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00,
        0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1,
        0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80,
        0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
        0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01,
        0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
        0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81,
        0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
        0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,
        0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
        0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80,
        0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00,
        0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
        0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
        0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40};

const unsigned char G_auchCRCLo[] = {0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6,
        0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF,
        0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19,
        0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
        0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 0x11,
        0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6,
        0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E,
        0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29,
        0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4,
        0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21,
        0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7,
        0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE,
        0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB,
        0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74,
        0x75, 0xB5, 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70,
        0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
        0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A,
        0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B,
        0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 0x44, 0x84, 0x85,
        0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40};

void readConfig(const char* path, const string& key, string& out_ptr)
{
        fstream cfgFile;
        cfgFile.open(path); //Open cfg file

        if (!cfgFile.is_open()) {
                return;
        }

        while (!cfgFile.eof()) { //Read file by line in loop
                char tmp[200] = {0};
                cfgFile.getline(tmp, 200);
                string line(tmp);
                size_t pos = line.find('=');

                if (pos == string::npos) {
                        cfgFile.close();
                        return;
                }

                string tmpKey = line.substr(0, pos);
                if (key == tmpKey) {
                        string tmpValue = line.substr(pos + 1);
                        cfgFile.close();
                        out_ptr = tmpValue;
                }
        }

        cfgFile.close();

        return;
}

uint16_t crc16(uint8_t *str, uint16_t len)
{
        uint8_t uchCRCHi = 0xff;
        uint8_t uchCRCLo = 0xff;
        uint8_t uIndex;

        while (len--) {
                uIndex = uchCRCHi ^ (*str++);
                uchCRCHi = uchCRCLo ^ G_auchCRCHi[uIndex];
                uchCRCLo = G_auchCRCLo[uIndex];
        }

        return (uchCRCHi | uchCRCLo << 8);
}

string getServerTime()
{
        char time_str[64] = {0};
        time_t t;
        time(&t);
        const char* format = "%Y-%m-%dT%H:%M:%S.000+08:00";
        strftime(time_str, sizeof(time_str), format, localtime(&t));

        return string(time_str);
}

string getHexString(u8* s, const u32& len)
{
        std::ostringstream out ;
        out << std::hex << std::setw(2) << std::setfill('0');

        for (u32 i = 0; i < len; i++) {
                out << std::hex << std::setw(2) << std::setfill('0')
                        << static_cast<int>(s[i]) << " ";
        }

        return out.str();
}

int bat(int d, int& sb, int& nb, string& is_signed)
{
        uint32_t t = ((1ULL << nb) - 1) << sb;
        d &= t;
        d = (d >> sb);

        if (is_signed == "true") {
                if (nb == 1) {
                        return d;
                }
                if ((d >> (nb - 1)) & 1) { // 负数
                        d = ~d + 1;
                        d &= (1ULL << nb) - 1;
                        d = ~d + 1;
                } else {
                        d &= (1ULL << nb) - 1;
                }
        } else {
                d &= (1ULL << nb) - 1;
        }

        return d;
}

u16 unbat(u16 old, int& sb, int& nb, int& value)
{
        int t = ~(((1 << nb) - 1) << sb);
        old = (old & t);

        int data = 0;

        if (value >= 0) {
                data = old | (value << sb);
        } else {
                value = ~value + 1;
                data = old | (value << sb);
        }

        return data;
}

unsigned int getbitu(const unsigned char *buff, int pos, int len)
{
        unsigned int bits = 0;
        int i;
        for (i = pos; i < pos + len; i++) {
                bits = (bits << 1) + ((buff[i / 8] >> (7 - i % 8)) & 1u);   //从高位到低位逐位计算
        }
        return bits;
}

float HexToFloat(const unsigned char *buf)
{
        float value = 0.0;
        unsigned int i = 0;
        unsigned int num, temp;
        int num2;
        bool flags1 = true;

        num = getbitu(buf, i, 1); //标志位
        i = i + 1;
//指数部分,float型数据其规定偏移量为127,阶码有正有负，对于8位二进制，则其表示范围为-128-127
        num2 = getbitu(buf, i, 8) - 127;
        i = i + 8;

        while (1) {
                if (flags1) {
                        value += 1 * pow(2, num2);
                        num2--;
                        flags1 = false;
                }
                temp = getbitu(buf, i, 1);
                i += 1;
                value += temp * pow(2, num2);
                num2--;

                if (i == 32) break;
        }

        if (num == 1) value *= -1;

	cout << "HexToFloat :" << value << endl;
        return value;
}

double HexToDouble(const unsigned char* buf)
{
        double value = 0;
        unsigned int i = 0;
        unsigned int num, temp;
        int num2;
        bool flags1 = true;

        num = getbitu(buf, i, 1); //标志位
        i += 1;
//double型规定偏移量为1023，其表示范围为-1024-1023
        num2 = getbitu(buf, i, 11) - 1023;
        i += 11;

        while (1) {
                if (flags1) {
                        flags1 = false;
                        value += 1 * pow(2, num2);
                        num2--;
                }
                temp = getbitu(buf, i, 1);
                i += 1;
                value += temp * pow(2, num2);
                num2--;
                if (i == 64) break;
        }
        if (num == 1) value *= -1;

        return value;
}

double calcFactor(float a)
{
        /*
         int sb = atoi(v[t.startBits].c_str());
         int nb = atoi(v[t.noBits].c_str());
         string is_signed = v[t.sign];
         d1 = bat(d1, sb, nb, is_signed);
         double data = (double)d1 * atof(v[t.factor].c_str());
         return data;
         */
        return 0.0;
}

long getMilliseconds()
{
        struct timeval aaasss;
        gettimeofday(&aaasss, NULL);
        return aaasss.tv_sec * 1000 + aaasss.tv_usec / 1000;
}

string floatReserve(const double& f, const int& point)
{
        char* p = new char[sizeof(int)*8 + point];
        snprintf(p, sizeof(int)*8 + point, ("%." + to_string(point) + "f").c_str(), f);
        string s(p);
        delete[] p;
        p = nullptr;

        return s;
}
